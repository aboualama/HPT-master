store Reaction-SMC
public function store(Request $request)

    dd($request->all());
    $rules = $this->rules();
    $rules = $rules + ['img_answers.*' => 'required|mimes:jpg,jpeg,png|max:20000',];
    $messages = $this->messages();
    $validator = Validator::make($request->all(), $rules, $messages);
    if ($validator->fails()) {
      return response()->json(['errors' => $validator->errors(), 'status' => 442]);
    }

    $record = new Question();
    $record['type'] = $request->type;
    $record->save();

    foreach(config('translatable.locales') as $lang){
      $data = $request->get($lang);
            $recordQ = new QuestionTranslation();
            $recordQ['locale'] = $lang;
            $recordQ['question'] = $data['question'];
            $recordQ['question_id'] = $record['id'];
            $recordQ->right_answers = json_encode($data['right_answers']);
            $recordQ->wrong_answers = json_encode($data['wrong_answers']);
            $recordQ->save();
    }


    $img = [];
    $index = count($request->en['right_answers']);

    for($i = 0 ; $i < $index ; $i++)
    {
      if (isset($request->file('img_answers')[$i])) {
          $image = $request->file('img_answers')[$i];
          $public_path = 'uploads/image';
          $img_name = $i . time() . '.' . $image->getClientOriginalExtension();
          $image->move($public_path , $img_name);
          $img[] = $img_name;
      }
      else {
          $img[] = 'default.jpg';
      }
    }




    $record['image'] = json_encode($img);
    $record->update();
    return response()->json(['status' => 200]);

}


  public function convert(Request $request , $id)
  {
    $headers = ['Content-Type' => 'application/pdf',];
    // $data = $request->all();
    // dd($result);
    $data = Useranswer::find($id);
    $result = ArrayToXml::convert(json_decode($data->answer, true));

    $public_path = 'uploads/file/';
    $file_name = 'Result_'.$id.'.xml';
    $file = Response::make($result, 200)->header('Content-Type', 'application/xml');
    File::put($public_path . $file_name , $result);
    $file_path = public_path('uploads/file/' . $file_name);

    // return  Response::download($file_path);
    // Response::make($result, 200)->header('Content-Type', 'application/xml');
    // $file =   Response::download($file, $file_name , $headers);

    //return Storage::disk('public')->download($file_path);
    return Storage::download($public_path, $file_name, $headers);
  }



    public function update(Request $request,  $id)
    {
        // dd($request->all());

      $rules = $this->rules();
      if (request()->hasFile('img_answers')) {
        $rules = $rules + ['img_answers'   =>  'required|mimes:jpg,jpeg,png|max:20000'];
      }
      $messages = $this->messages();
      $validator = Validator::make($request->all(), $rules, $messages);
      if ($validator->fails()) {
        return response()->json(['errors' => $validator->errors(), 'status' => 442]);
      }

      $old = Question::find($id);
      $old_image = $old->image;
      $old->delete();
      $record = new Question();
      $record['type'] = $request->type;

      if ($request->hasFile('img_answers'))
      {
        if(isset($old_image) && $old_image !== 'default.jpg'){
          // unlink('uploads/image/'.$old_image);
        }
          $image = $request->file('img_answers');
          $public_path = 'uploads/image';
          $img_name = time() . '.' . $image->getClientOriginalExtension();
          $image->move($public_path , $img_name);
          $img = $img_name;
      }
      else {
          $img = $old_image;
      }

      $record['image'] = $img;
      $record->save();

      foreach(config('translatable.locales') as $lang){
        $data = $request->get($lang);
            $recordQ = new QuestionTranslation();
            $recordQ['locale'] = $lang;
            $recordQ['question'] = $data['question'];
            $recordQ['question_id'] = $record['id'];
            $recordQ->right_answers = $data['right_answers'];
            $recordQ->wrong_answers = json_encode($data['wrong_answers']);
            $recordQ->save();
      }
      $record->update();
      return response()->json($record);
    }



